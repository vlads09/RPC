/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "OAuth.h"
#include "Server_utils.h"
#include "token.h"

char **request_authorization_token_1_svc(authorization *argp,
                                         struct svc_req *rqstp) {
  static char *result;

  /*
   * insert server code here
   */
  printf("BEGIN %s AUTHZ\n", argp->id);
  fflush(stdout);

  result = NULL;
  for (int i = 0; i < clients->size; i++) {
    // verify if the user exists in db
    // if so, generate an authorization token
    if (!strcmp(argp->id, clients->clients[i])) {
      result = generate_access_token(argp->id);
      break;
    }
  }

  if (result == NULL) {
    result = "USER_NOT_FOUND";
  } else {
    printf("  RequestToken = %s\n", result);
    fflush(stdout);
  }

  return &result;
}

approve_response *approve_request_token_1_svc(approve *argp,
                                              struct svc_req *rqstp) {
  static approve_response result;

  /*
   * insert server code here
   */
  if (!prepare_approve_request_token_result(&result)) {
    return NULL;
  }

  strcpy(result.authorization_token, argp->authorization_token);

  // get the permission from db which is related with the request of the client
  char *permission = permissions->permissions[(permissions->current)++];
  char *permission_aux = calloc(50, sizeof(char));
  strcpy(permission_aux, permission);

  // verify if the resources exists in resources.db
  char *token;
  token = strtok(permission_aux, ",");
  int count = 0;
  int is_there = 0;
  while (token != NULL) {
    if (count % 2 == 0) {
      // verify resources' existence
      for (int i = 0; i < resources->size; i++) {
        if (!strcmp(token, resources->resources[i])) {
          is_there = 1;
          break;
        }
      }
      // if the resource given does not exist, then the request will be denied
      if (!is_there) {
        result.verify = 2;
        strcpy(result.permissions, "REQUEST_DENIED");
        return &result;
      }
      is_there = 0;
    }
    count++;
    token = strtok(NULL, ",");
  }
  // resources have been confirmed to be in the db
  // and the signature was a success
  result.verify = 1;

  // save permissions in the signature
  strcpy(result.permissions, permission);

  return &result;
}

access_response *request_access_token_1_svc(access *argp,
                                            struct svc_req *rqstp) {
  static access_response result;

  /*
   * insert server code here
   */

  result.access_token =
      generate_access_token(argp->authorization_token.authorization_token);

  // if the refresh mode is activated, then generate a refresh token
  // else just allocate and leave it empty
  if (atoi(argp->refresh) == 1) {
    result.refresh_token = generate_access_token(result.access_token);
  } else {
    result.refresh_token = calloc(16, sizeof(char));
    if (result.refresh_token == NULL) {
      printf("Error while allocating memory fro the access token result!\n");
      fflush(stdout);
      free(result.refresh_token);
      free(result.access_token);
      return NULL;
    }
  }

  result.valability = valability;
  printf("  AccessToken = %s\n", result.access_token);
  fflush(stdout);

  // if the server didn't initiate a list of users and their information
  // allocate it now
  if (cl_info == NULL) {
    cl_info = init_client_info();
    if (cl_info == NULL) {
      return NULL;
    }
    size_cl_info = 0;
  }

  if (modify_client_info(*argp, result)) {
    return &result;
  }

  add_client_info(*argp, result);

  return &result;
}

char **validate_delegated_action_2_svc(action *argp, struct svc_req *rqstp) {
  static char *result;

  /*
   * insert server code here
   */
  result = calloc(30, sizeof(char));
  if (result == NULL) {
    printf("Error while allocating memory for the validation!\n");
    fflush(stdout);
    free(result);
  }

  // if there are clients on the list
  // the 'if' is for when a user tries to make an action and it is on the list
  if (size_cl_info != 0 && generate_operation_status(result, *argp)) {
    return &result;
  }

  // user is not on the list
  strcpy(result, "PERMISSION_DENIED");
  printf("DENY (%s,%s,,0)\n", argp->operation, argp->source);
  fflush(stdout);
  return &result;
}

refresh_output *get_new_token_3_svc(refresh_input *argp,
                                    struct svc_req *rqstp) {
  static refresh_output result;

  /*
   * insert server code here
   */
  if (!prepare_new_token_result(&result)) {
    return NULL;
  }
  result.valability = valability;

  printf("BEGIN %s AUTHZ REFRESH\n", argp->id);
  fflush(stdout);

  // search for the user with the correct id and refresh token
  for (int i = 0; i < size_cl_info; i++) {
    if (strcmp(argp->id, cl_info[i].id) == 0 &&
        strcmp(argp->refresh, cl_info[i].refresh_token) == 0) {
      // update the values
      cl_info[i].valability = valability;
      strcpy(cl_info[i].access_token, generate_access_token(argp->refresh));
      strcpy(cl_info[i].refresh_token,
             generate_access_token(cl_info[i].access_token));

      strcpy(result.access_token, cl_info[i].access_token);
      strcpy(result.refresh_token, cl_info[i].refresh_token);

      printf("  AccessToken = %s\n", result.access_token);
      fflush(stdout);
      printf("  RefreshToken = %s\n", result.refresh_token);
      fflush(stdout);
      break;
    }
  }

  return &result;
}