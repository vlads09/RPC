/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "OAuth.h"
#include "OAuth_utils.h"
#include "token.h"

char **
request_authorization_token_1_svc(authorization *argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */
	printf("BEGIN %s AUTHZ\n", argp->id);
	fflush(stdout);
	result = NULL;
	for (int i = 0; i < clients->size; i++) {
		if (strcmp(argp->id, clients->clients[i]) == 0) {
			result = generate_access_token(argp->id);
			break;
		}
	}

	if (result == NULL) {
		result = "USER_NOT_FOUND";
	} else {
		printf("  RequestToken = %s\n", result);
	fflush(stdout);
	}
	return &result;
}

approve_response *
approve_request_token_1_svc(approve *argp, struct svc_req *rqstp)
{
	static approve_response  result;

	/*
	 * insert server code here
	 */
	// strtok verificat permisiunile daca sunt ok
	// tbc
	result.authorization_token = calloc(16, sizeof(char));
	result.permissions = calloc(50, sizeof(char));

	strcpy(result.authorization_token, argp->authorization_token);
	char *permission = permissions->permissions[(permissions->current)++];
	char *permission_aux = calloc(50, sizeof(char));
	strcpy(permission_aux, permission);

	char* token;
    token = strtok(permission_aux, ",");
    int count = 0;
	int is_there = 0;
    while (token != NULL) {
      if (count % 2 == 0) {
		for (int i = 0; i < resources->size; i++) {
			if(strcmp(token, resources->resources[i]) == 0) {
				is_there = 1;
				break;
			}
		}
		if (is_there == 0) {
			result.verify = 2;
			strcpy(result.permissions, "REQUEST_DENIED");
			return &result;
		}
		is_there = 0;
	  }
      count++;
      token = strtok(NULL, ",");
    }

	result.verify = 1;
	strcpy(result.permissions, permission);

	return &result;
}

access_response *
request_access_token_1_svc(access *argp, struct svc_req *rqstp)
{
	static access_response  result;

	/*
	 * insert server code here
	 */

	result.access_token = generate_access_token(argp->authorization_token.authorization_token);
	if (atoi(argp->refresh) == 1) {
		result.refresh_token = generate_access_token(result.access_token);	
	} else {
		result.refresh_token = calloc(16, sizeof(char));
	}
	result.valability = valability;
	printf("  AccessToken = %s\n", result.access_token);
	fflush(stdout);

	if (cl_info == NULL) {
		cl_info = init_client_info();
		size_cl_info = 0;
	}

	for (int i = 0; i < size_cl_info; i++) {
		if (strcmp(argp->id, cl_info[i].id) == 0) {
			strcpy(cl_info[i].permissions, argp->authorization_token.permissions);
			strcpy(cl_info[i].access_token, result.access_token);
			if (atoi(argp->refresh) == 1) {
				strcpy(cl_info[i].refresh_token, result.refresh_token);
			}
			strcpy(cl_info[i].refresh, argp->refresh);
			cl_info[i].valability = valability;

			return &result;
		}
	}
	strcpy(cl_info[size_cl_info].id, argp->id);
	strcpy(cl_info[size_cl_info].permissions, argp->authorization_token.permissions);
	strcpy(cl_info[size_cl_info].access_token, result.access_token);

	if (atoi(argp->refresh) == 1) {
		strcpy(cl_info[size_cl_info].refresh_token, result.refresh_token);
	}
	strcpy(cl_info[size_cl_info].refresh, argp->refresh);
	cl_info[size_cl_info++].valability = valability;
	
	return &result;
}

char **
validate_delegated_action_2_svc(action *argp, struct svc_req *rqstp)
{
	static char * result;

	/*
	 * insert server code here
	 */
	result = calloc(30, sizeof(char));

	if (size_cl_info != 0) {
		for (int i = 0; i < size_cl_info; i++) {
			if (strcmp(argp->access_token, cl_info[i].access_token) == 0) {
				if (cl_info[i].valability > 0) {
					(cl_info[i].valability)--;

					int found_resource = 0;
					for (int j = 0; j < resources->size; j++) {
						if (strcmp(argp->source, resources->resources[j]) == 0) {
							found_resource = 1;
							break;
						}
					}
					if (found_resource == 0) {
						strcpy(result, "RESOURCE_NOT_FOUND");
						printf("DENY (%s,%s,%s,%d)\n", argp->operation, argp->source, argp->access_token, 
												cl_info[i].valability);
						fflush(stdout);
						return &result;
					}
					
					char *resources_aux = calloc(50, sizeof(char));
					strcpy(resources_aux, cl_info[i].permissions);

					char* token;
    				token = strtok(resources_aux, ",");

					int count = 0;
					while (token != NULL) {
						if (count % 2 == 0) {
							if (strcmp(argp->source, token) == 0) {
								token = strtok(NULL, ",");

								for (int j = 0; j < strlen(token); j++) {
									if (token[j] == 'X') {
										token[j] = 'E';
									}
									if (argp->operation[0] == token[j]) {
										strcpy(result, "PERMISSION_GRANTED");
										printf("PERMIT (%s,%s,%s,%d)\n", argp->operation, argp->source, argp->access_token, 
											cl_info[i].valability);
										fflush(stdout);
										return &result;
									}
								}

								strcpy(result, "OPERATION_NOT_PERMITTED");
								printf("DENY (%s,%s,%s,%d)\n", argp->operation, argp->source, argp->access_token, 
											cl_info[i].valability);
								fflush(stdout);
								return &result;
							}
						}
						
						token = strtok(NULL, ",");
						count++;
					}
					strcpy(result, "OPERATION_NOT_PERMITTED");
					printf("DENY (%s,%s,%s,%d)\n", argp->operation, argp->source, argp->access_token, 
								cl_info[i].valability);
					fflush(stdout);
					return &result;
				}
				strcpy(result, "TOKEN_EXPIRED");
				printf("DENY (%s,%s,,%d)\n", argp->operation, argp->source, cl_info[i].valability);
				fflush(stdout);
				return &result;
			}
		}
	}

	strcpy(result, "PERMISSION_DENIED");
	printf("DENY (%s,%s,,0)\n", argp->operation, argp->source);
	fflush(stdout);
	return &result;
}
